<?xml version="1.0" encoding="utf-8"?>

<!--
/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2010, the WOW agency All rights reserved.
// Author: Matteo Corazzin.
// See http://www.thewowagency.com/ for full details
/////////////////////////////////////////////////////////////////////////
-->

<BaseComponent xmlns="org.glomaker.shared.component.*" 
	xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:inputoutput="org.glomaker.plugin.inputoutput.*"
	layout="absolute">

<mx:Style>
	
	.submit {
		upSkin: Embed("assets/submit1.png");
	  	overSkin: Embed("assets/submit2.png");
	  	downSkin: Embed("assets/submit1.png");
	  	disabledSkin: Embed("assets/submit1.png");
	}
</mx:Style>

<mx:Script>
	<![CDATA[
		import org.glomaker.shared.utils.MutableArray;
		import mx.states.SetStyle;
		import org.glomaker.shared.properties.NumericStepperProperty;
		import mx.controls.TextInput;
		import org.glomaker.shared.properties.ColourProperty;
		import org.glomaker.shared.properties.ArrayProperty;
		import org.glomaker.shared.properties.StringProperty;
		import org.glomaker.shared.properties.IntegerProperty;
		import org.glomaker.shared.properties.IComponentProperty;
		import org.glomaker.shared.properties.BooleanProperty;
		
		import mx.core.mx_internal;
	
	[Bindable]
	[Embed(source="assets/text_bg.jpg")]
	
	protected static var textBg:Class;
	
	protected var setOutput:BooleanProperty;
	
	protected var memorySet:BooleanProperty;
	
	protected var outputElementsProperty:ArrayProperty;
	
	protected var outputElementsArray:Array = [];
	
	protected var fontColour:ColourProperty;
	
	protected var fontSize:NumericStepperProperty;
	
	protected var editMode:Boolean;
	
	protected var inputEditScreen:InputEditingScreen;
	
	protected var outputEditScreen:OutputEditingScreen;
	
	protected var outputScreen:OutputScreen;
	
	protected var memoryObject:Object;
	
	//protected var numFields:NumericStepperProperty;
	
	//protected var isLoaded:BooleanProperty; 
	
	//private var _inputElementsArray:Array = new Array("a", "b", "c", "d", "e", "", "", "");
	
	private var inputID:StringProperty;
	
	private var sessionName:String ="inputElement_" ;
	
	[Bindable]
	private var _fc:uint;
	
	[Bindable]
	private var _fs:uint;
	
	
	override protected function defineProperties():void
	{
		
		super.defineProperties();
		
		setOutput = new BooleanProperty("inputOutput", "Output", false);
		addProperty(setOutput);
		
		fontColour = new ColourProperty("fontColour", "Font Colour", 0);
		addProperty(fontColour);
		
		fontSize = new NumericStepperProperty("fontSize", "Font Size", 12);
		addProperty(fontSize);
		
		//numFields = new NumericStepperProperty("numFields", "Number of output fields", 1);
		//addProperty(numFields);
		
		memorySet = new BooleanProperty("memorySet", "", false);
		addSaveableProperty(memorySet);
		
		/* isLoaded = new BooleanProperty("isLoaded", "", false);
		addSaveableProperty(isLoaded); */ 
		
		outputElementsProperty = new ArrayProperty("outputElements", "Elements", outputElementsArray);
		addSaveableProperty(outputElementsProperty);
		
		inputID = new StringProperty("input", "ID", "");
		addSaveableProperty(inputID);
	}
	
	override public function editablePropertyUpdated(prop:IComponentProperty):void
	{
		if(prop == fontColour)
		{
			_fc = prop.propValue;
			
			if(outputScreen)
			{
				outputScreen.color = prop.propValue;
			}
		}
		
		if(prop == fontSize)
		{
			_fs = prop.propValue;
			
			lines.setLineHeight = 1.34 * prop.propValue;
			
			if(outputScreen)
			{
				outputScreen.fontSize = prop.propValue;
			}
		}
		
		setMode();
	}
	
	override public function propertyValuesInitialised():void
	{		
		setMode();
		
		_fc = fontColour.propValue;
		_fs = fontSize.propValue;
			
		lines.setLineHeight = 1.34 * fontSize.propValue;
		
		//populateTextFields();	

		//if(memorySet.propValue)
		//{	
			
			var thisElement:String = sessionName + inputID.propValue;
			var readFromText:String;
			
			try
			{
				readFromText = readFromMemory(thisElement);
				
			}catch(e:Error)
			{
				trace(e.message);
				return;
			}
			
			if(readFromMemory(thisElement) != undefined)
			{
				inputArea.htmlText = readFromMemory(thisElement);
			}
			
			if(setOutput.propValue && !editMode)
			{

				if(outputScreen)
				{
					for(var i:uint=0; i<outputElementsProperty.propValue.length; i++)
					{
						thisElement = sessionName + outputElementsProperty.propValue[i];
						try
						{
							readFromText = readFromMemory(thisElement);
							
						}catch(e:Error)
						{
							trace(e.message);
							return;
						}
						
						if(readFromMemory(thisElement) != undefined)
						{
							outputScreen.text += "\n\n" + readFromMemory(thisElement);
						}
					}
					
					outputScreen.color = fontColour.propValue;
					outputScreen.fontSize = fontSize.propValue;
				}
			}
		//}		
	}
	
	override public function prepareValuesForSave():void
	{
		//trace("1 "+ setOutput.propValue, "2 "+ editMode, "3 "+inputID.propValue);
		
		if(inputEditScreen)
		{
			//trace("E"+ inputID.propValue);
			inputEditScreen.inputID = inputID.propValue;
		}
		
		if(outputEditScreen)
		{
			populateInputFields();
		}

	}
	
	override protected function componentInitComplete():void
	{
		trace("COMPLETE");
	}
	
	override public function setEditMode(f:Boolean):void
	{
		editMode = f;
		setMode();
	}
		
	protected function setMode():void
	{
		this.removeAllChildren();
				
		if(setOutput.propValue)
			{
				//we must be in output mode
				//addNumericStepper();
				if(editMode)
				{
					//we are editing the output screen
					if(!outputEditScreen)
					{
						outputEditScreen = new OutputEditingScreen();
						outputEditScreen.addEventListener(Event.CHANGE, onInputIDChange);
					}
					
					populateInputFields();
					this.addChild(outputEditScreen);
				}else
				{
					//we are seeing the output screen
					if(!outputScreen)
					{
						outputScreen = new OutputScreen();
					}
					this.addChild(lines);
					this.addChild(outputScreen);
				}
			}else
			{
				//we must be in input mode
				//removeNumericStepper();
				if(editMode)
				{
					//we are editing the input screen
					if(!inputEditScreen)
					{
						inputEditScreen = new InputEditingScreen();
						inputEditScreen.addEventListener(Event.CHANGE, onInputIDChange);
					}
					
					inputEditScreen.inputID = inputID.propValue;
					this.addChild(inputEditScreen);
				}else
				{
					//we are seeing the input screen
					this.addChild(lines);
					this.addChild(inputArea);
					
				}
			}
	}
	
	/* protected function addNumericStepper():void
	{
		var props:Array = getEditableProperties().source;
		
		for(var i:uint=0; i<props.length; i++)
		{
			if(props[i] == numFields)
			{
				return;
			}
		}
		
		if(numFields)
		{
			props.push(numFields);
			updateEditableProperties(props);
		}
		
	} */
	
	/* protected function removeNumericStepper():void
	{
		var props:Array = getEditableProperties().source;
		
		for(var i:uint=0; i<props.length; i++)
		{
			if(props[i] == numFields)
			{
				props.splice(i, 1);
				
				updateEditableProperties(props);
				break;
			}
		}
	} */
	
	protected function onInputIDChange(evt:Event):void
	{
		if(evt.target is InputEditingScreen)
		{
			inputID.propValue = (evt.target as InputEditingScreen).inputID;
			
			if(inputEditScreen)
			{
				storeText();
			}
		}

		if(evt.target is OutputEditingScreen)
		{
			var fieldsArray:Array = (evt.target as OutputEditingScreen).inputFields;
			
			outputElementsProperty.propValue = fieldsArray;
			
			//outputElementsProperty.propValue = (evt.target as OutputEditingScreen).inputFields;
			//outputElementsArray = (evt.target as OutputEditingScreen).inputFields;
			/* var IDs:Array = (evt.target as OutputEditingScreen).inputFields;
			outputElementsProperty.propValue = [];
			
			for(var i:uint=0; i<IDs.length; i++)
			{
				outputElementsProperty.propValue.push((outputEditScreen.getInputID(i) as TextInput).text);
				
			}
			
			if(outputEditScreen)
			{
				storeText();
			} */
		}
		
	}
	protected function onUserInput(evt:Event):void
	{
		storeText();
	}
	
	
	protected function storeText():void
	{
		var thisElement:String = sessionName + inputID.propValue;
		
		try
		{
			writeToMemory(thisElement, inputArea.text, true);
		}catch(error:Error)
		{
			trace(error);
			return;
		}
		
		
		memorySet.propValue = true;
	}
	
	protected function populateInputFields():void
	{
		for(var i:uint=0; i<outputElementsProperty.propValue.length; i++)
		{

			outputEditScreen.setInputID(i, outputElementsProperty.propValue[i]);

		}
		/* trace("1"+outputEditScreen, outputElementsProperty.propValue);
		if(!outputEditScreen)
		{
			return;
		}
		
		for(var i:uint=0; i<outputElementsProperty.propValue.length; i++)
		{
			if(i + 1 >= outputEditScreen.inputFields.length)
			{
				break;
			}else
			{
				outputEditScreen.setInputID(i, outputElementsProperty.propValue[i]);
				trace("£££"+i, outputElementsProperty.propValue[i]);
			}
		} */
	}
		
	]]>
</mx:Script>
	<inputoutput:Lines setLineHeight="12" id="lines" />
    <mx:TextArea id="inputArea" color="{_fc}" fontSize="{_fs}" editable="true" 
    	width="100%" height="100%" 
    	change="onUserInput(event)"
    	horizontalScrollPolicy="off" verticalScrollPolicy="off"
    	backgroundAlpha="0"/>
    	


</BaseComponent>
