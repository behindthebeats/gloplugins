<?xml version="1.0" encoding="utf-8"?>

<!--
/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2007-09 LTRI, London Metropolitan Uni. All rights reserved.
// An Open Source Release under the GPL v3 licence  (see http://www.gnu.org/licenses/).
// Authors: Tom Boyle, Nils Millahn, Musbah Sagar, Martin Agombar.
// See http://www.glomaker.org for full details
/////////////////////////////////////////////////////////////////////////
-->

<BaseComponent xmlns="org.glomaker.shared.component.*" 
	xmlns:mx="http://www.adobe.com/2006/mxml" 
	width="100%" height="100%">
	
	<mx:Script>
		<![CDATA[
			import org.glomaker.shared.properties.ColourProperty;
			import org.glomaker.shared.properties.StringProperty;

			import org.glomaker.shared.properties.FilePathProperty;
			import org.glomaker.shared.properties.IComponentProperty;
			import org.glomaker.shared.properties.BooleanProperty;
			
			/**
		 	* Embed play button up skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_play.png")]	
			public var playBtn:Class;
			
			/**
		 	* Embed play rollover skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_play_rollover.png")]	
			public var playRolloverBtn:Class;
			
			/**
		 	* Embed pause button up skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_pause.png")]	
			public var pauseBtn:Class;
			
			/**
		 	* Embed pause rollover skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_pause_rollover.png")]	
			public var pauseRolloverBtn:Class;
			
			/**
		 	* Embed forward button up skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_forward.png")]	
			public var fwdBtn:Class;
			
			/**
		 	* Embed forward rollover skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_forward_rollover.png")]	
			public var fwdRolloverBtn:Class;
			
			/**
		 	* Embed back button up skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_rewind.png")]	
			public var backBtn:Class;
			
			/**
		 	* Embed back rollover skin.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/controls_rewind_rollover.png")]	
			public var backRolloverBtn:Class;
			
			/**
		 	* Embed AVM1Loader.
		 	*/
			[Bindable]
			[Embed(source="org/glomaker/plugin/swfloader/assets/localConnection.swf")]	
			public var AVM1Loader:Class;
			
			/**
		 	* Sets up a Browse control button on the Property Panel.
		 	*/
			protected var filePath:FilePathProperty;
			
			/**
		 	* Sets up a field on the Property Panel to control the existence of the play button.
		 	*/
			protected var playControl:BooleanProperty;
			
			/**
		 	* Sets up a field on the Property Panel to control the existence of the jump button.
		 	*/
			protected var jumpControl:BooleanProperty;			
			
			/**
		 	* Sets up a field on the Property Panel to control the colour of thebackground strip .
		 	*/
			protected var bgColour:ColourProperty;
			
			/**
		 	* Stores a true or false value relating to the existence of the play button.
		 	*/
			private var _playControlVisible:Boolean;
			
			/**
		 	* Stores a true or false value relating to the existence of the jump button.
		 	*/
			private var _jumpControlVisible:Boolean;
			
			/**
		 	* Stores an array of MovieClip labels.
		 	*/
			private var _labels:Array;
			
			/////////////////////////
			
			/**
		 	* Sets up an invisible property that stores a true / false value depending
		 	* on whether the loaded asset is an AVM1 movie or not.
		 	*/
		 	protected var isAVM1:BooleanProperty;
		 	
		 	/**
		 	* Stores the unique connectionID for this instance. Used to connect with the AVM1Loader.
		 	*/
		 	protected var connectionID:StringProperty;
		 	
		 	/**
		 	* Stores the local connection object, effectively making this module a server.
		 	*/
			protected var AVM_lc:CustomLocalConnection;
			
			/**
		 	* Stores the instance of the AVM1Loader that is used permenantly as the bridge to AVM1 movies.
		 	*/
			private var _AVM1LoaderInstance:DisplayObject;
			
			/**
		 	* Collection of all the AVM1 loaders. Necessary to avoid cross-talk problems.
		 	*/			
			private static var _AVM1Loaders:Dictionary = new Dictionary();
			
			////////////////////////
			
			
			/**
		 	* Called by GLOMaker when the properties need to be defined.
		 	*/
			override protected function defineProperties():void
			{
				super.defineProperties();
				
				playControl = new BooleanProperty("playControlValue", "Play button ?", true);
				jumpControl = new BooleanProperty("labelControlValue", "Jump button ?", true);
				
				filePath = new FilePathProperty("filepath", "File Path:", "");
				filePath.fileTypeLabel = "SWFs and Images"; 
				filePath.fileExtensions = "*.jpg;*.gif;*.png;*.swf";
			
				bgColour = new ColourProperty("bgcolour", "Colour", 0x666666);
	
				connectionID = new StringProperty("connectionID", "", "StringProperty::NotSet");
				isAVM1 = new BooleanProperty("isAVM1", "", false);
				
				addProperty(filePath);
				addProperty(bgColour);
				addProperty(playControl);
				addProperty(jumpControl);
				
				addSaveableProperty(connectionID);
				addSaveableProperty(isAVM1);

			}
			
			/**
		 	* Called by GLOMaker when the properties need to be initialised.
		 	*/
			override public function propertyValuesInitialised():void
			{
				_playControlVisible = playControl.propValue;
				_jumpControlVisible = jumpControl.propValue;
				
				// initialise LocalConnection...
				initLocalConnection();
				
				if(checkConnectionIDExists(connectionID.propValue) == null)
				{
					// this component has not been set up. It needs an AVM1Loader
					// the initialisation process will now begin
					swfLoader.source = new AVM1Loader();
					
					
				}else if(!isAVM1.propValue)
				{
					// we already have an AVM1Loader and the media is not AVM1 anyway.
					// go ahead and load
					swfLoader.load(filePath.propValue);
				}else
				{	
					// we already have an AVM1Loader and the media is an AVM1.
					// load AVM1 movie
					loadAVM1Loader();
					loadAVM1Movie();
					
					updateEditableProperties([filePath, bgColour, playControl]);
					_playControlVisible = true;
					_jumpControlVisible = false;
				}
				
				controls.setStyle("backgroundColor", bgColour.propValue);
				
				buildControls();
			}
			
			/**
		 	* Called by GLOMaker when the properties need to be updated.
		 	*/
			override public function editablePropertyUpdated(prop:IComponentProperty):void
			{
				switch(prop)
				{						
					case playControl:
					
						_playControlVisible = prop.propValue;
						buildControls();
						
						break;
						
					case jumpControl:
					
						_jumpControlVisible = prop.propValue;
						buildControls();

						break;	
						
					case filePath:
					
						swfLoader.source = prop.propValue;	
						
						break
						
					case bgColour:
					
						controls.setStyle("backgroundColor", bgColour.propValue);
						
						break;
				}
			}
			
			override public function destroy():void
			{
				AVM_lc = new CustomLocalConnection("host" + connectionID.propValue);	
						
				AVM_lc.send(connectionID.propValue, "destroy");
				
				closeConnection();
			}
			
			protected function buildControls():void
			{
				// start with a clean sheet
				controls.removeAllChildren();
				
				if(_jumpControlVisible == false && _playControlVisible == false)
				{
					// no buttons to display. make controls invisible
					controls.visible = false;
					
				}else{
					
					controls.visible = true;

					if(_playControlVisible)
					{	
						controls.addChild(stop);
						controls.addChild(play);
					}

					if(_jumpControlVisible)
					{
						controls.addChildAt(back, 0);
						controls.addChild(fwd);
					}
				}
			}
			
			///////////////////////////////////////////////////////
			//
			// AVM1 
			//
			///////////////////////////////////////////////////////
			
			protected function initLocalConnection():void
			{
				// this connection has also been set up in the local connection SWF
				// and will be used once only for initialisation purposes
				
				// ensure there is no connection still running
				if(AVM_lc != null)
				{
					AVM_lc.close();
				}
				
				// create connection
				AVM_lc = new CustomLocalConnection("AVM1toAVM2");
				
				// listens for the local connection SWF sending an event indicating it has loaded
				// and is operational
				AVM_lc.addEventListener(Event.INIT, onAVM1LoaderInitialised);
				
				// catches error messages associated with the connection
				AVM_lc.addEventListener(StatusEvent.STATUS, onStatusError);
				
			}
			
			/**
		 	* The localConnection SWF is set up to make a local connection call once it is ready to load
		 	* an AVM1 movie.
		 	*/
			protected function onAVM1LoaderInitialised(evt:Event):void
			{	
			
				// add the information to AVM1LoaderInfo			
				var AVM1Object:AVM1LoaderInfo = new AVM1LoaderInfo();
				AVM1Object.content = swfLoader.content;
				AVM1Object.connectionID = (evt.target as CustomLocalConnection).id;
				AVM1Object.isAVM1 = false;
				
				connectionID.propValue = (evt.target as CustomLocalConnection).id;
				
				// now we have the unique ID, destroy the original connection...
				closeConnection();
				
				// add AVM1Object to dictionary
				_AVM1Loaders[AVM1Object.connectionID] = AVM1Object;
				
				// we may need to load a movie at this point
				if(isAVM1.propValue && filePath.propValue != "FilePathProperty::NoUrlSet" )
				{
					// we must need to load non-AVM1 content
					swfLoader.load(filePath.propValue);
				}
				
				if(!isAVM1.propValue && filePath.propValue != "FilePathProperty::NoUrlSet" )
				{
					loadAVM1Loader();
					loadAVM1Movie();
				}
				 
			}
			
			protected function loadAVM1Loader():void
			{
				// get loader
				var info:AVM1LoaderInfo = _AVM1Loaders[connectionID.propValue] as AVM1LoaderInfo;
				
				swfLoader.source = info.content;
				
				// we need to establish how the movie will fit the available space
				var containerAspectRatio:Number = swfLoaderContainer.width / swfLoaderContainer.height;
				var movieAspectRatio:Number = info.width / info.height;
				
				// use the aspect ratios to determine whether to match 
				// the height or width of the available space
				
				// set swfLoader dimensions
				var conversion:Number;
				
				if(containerAspectRatio >= movieAspectRatio)
				{
					// the available space is of a wider format
					// use the height of the available space as the determining factor
					conversion = swfLoaderContainer.height / 400 info.height * 100;
					swfLoader.percentHeight = conversion;
				}else
				{
					// the movie is of a wider format
					// use the width of the available space as the determining factor
				}
				
				
				swfLoader.percentWidth = (swfLoader.width / (swfLoader.width * conversionW)) * 100;
				//swfLoader.percentHeight = 40;
				
				trace(swfLoader.width / (swfLoader.width * conversionW) * 100);
			}
			
			protected function loadAVM1Movie():void
			{			
				AVM_lc = new CustomLocalConnection("host" + connectionID.propValue);	
						
				AVM_lc.send(connectionID.propValue, "load",  filePath.propValue);
				
				closeConnection();
			}
			
			protected function checkConnectionIDExists(id:String):AVM1LoaderInfo
			{
				if(_AVM1Loaders[id] is AVM1LoaderInfo)
				{
					return _AVM1Loaders[id] as AVM1LoaderInfo;
				}else
				{
					return null;
				}
			}
			
			protected function closeConnection():void
			{
				try
	            {
	                AVM_lc.close();
	            }
	            catch (error:ArgumentError)
	            {
	                trace("AVM_lc failed to close.");
				}
			}
			
			/**
		 	* Catches any error messages from the local connection process.
		 	*/
			protected function onStatusError(evt:StatusEvent):void
			{
				trace("Local Connection Status Error: " + evt);
			}
			
			
			///////////////////////////////////////////////////////
			//
			// Event Handlers
			//
			///////////////////////////////////////////////////////
			
			protected function onSWFLoaderComplete(evt:Event):void
			{
				// determine what has been loaded
				
				if(swfLoader.content is Bitmap)
				{
					// easy, nothing to do
					isAVM1.propValue = false;
					
					//playControl.propValue = null;
					//jumpControl.propValue = null;
					
					container.removeChild(controls);
					
					updateEditableProperties([filePath, bgColour]);
					
					return;
				}
				
				if(swfLoader.content is MovieClip)
				{

					_labels = (swfLoader.content as MovieClip).currentLabels;
					
					isAVM1.propValue = false;
					
					//playControl.propValue = true;
					//jumpControl.propValue = true;
							
					_playControlVisible = true;
					_jumpControlVisible = true;
							
					buildControls();
							
					container.addChild(controls);
					
					updateEditableProperties([filePath, bgColour, playControl, jumpControl]);
					
					return

				}
				
				if(swfLoader.content is AVM1Movie)
				{
					// grab its dimensions
					var info:AVM1LoaderInfo = _AVM1Loaders[connectionID.propValue] as AVM1LoaderInfo;
					info.width = (swfLoader.content as AVM1Movie).loaderInfo.width;
					info.height = (swfLoader.content as AVM1Movie).loaderInfo.height;
					
					// we need the AVM1 
					loadAVM1Loader();
					loadAVM1Movie();
				
					isAVM1.propValue = true;
					
					//playControl.propValue = true;
					//jumpControl.propValue = null;
							
					_playControlVisible = true;
					_jumpControlVisible = false;
							
					buildControls();
							
					container.addChild(controls);
					
					updateEditableProperties([filePath, bgColour, playControl]);
				}
			}
			
			protected function onBack(evt:MouseEvent):void
			{
				// only used when a MovieClip is loaded
				var previousFrameLabel:FrameLabel = getFrameLabel("back");
				
				if(previousFrameLabel != null)
				{
					(swfLoader.content as MovieClip).gotoAndStop(previousFrameLabel.frame);
				}
			}
			
			protected function onFwd(evt:MouseEvent):void
			{	
				// only used when a MovieClip is loaded
				var nextFrameLabel:FrameLabel = getFrameLabel("fwd");
				
				if(nextFrameLabel != null)
				{
					(swfLoader.content as MovieClip).gotoAndStop(nextFrameLabel.frame);
				}
			}
			
			protected function onPlay(evt:MouseEvent):void
			{
				if(isAVM1.propValue)
				{
					AVM_lc = new CustomLocalConnection("host" + connectionID.propValue);	
						
					AVM_lc.send(connectionID.propValue, "play");
				
					closeConnection();
				}else
				{
					if(swfLoader.content is MovieClip)
					{
						(swfLoader.content as MovieClip).play();
					}
					
				}
			}
			
			protected function onStop(evt:MouseEvent):void
			{
				if(isAVM1.propValue)
				{
					AVM_lc = new CustomLocalConnection("host" + connectionID.propValue);	
						
					AVM_lc.send(connectionID.propValue, "stop");
				
					closeConnection();
				}else
				{
					if(swfLoader.content is MovieClip)
					{
						(swfLoader.content as MovieClip).stop();
					}
				}
			}
			
			protected function getFrameLabel(direction:String):FrameLabel
			{
				var fl:FrameLabel = null;
				
				if(getLabelIndex() < 0)
				{
					return fl;
				}
				
				if(direction == "current")
				{
					fl = (swfLoader.content as MovieClip).currentLabel as FrameLabel;
					
					return fl;
				}

				var currentIndex:int = getLabelIndex();
				
				if(direction == "back")
				{
					if(currentIndex == _labels.length)
					{
						fl = _labels[currentIndex] as FrameLabel;
						
					}else{
						
						fl = _labels[currentIndex + 1] as FrameLabel;

					}
					
					return fl;
				}
				
				if(direction == "fwd")
				{
					if(currentIndex == 0)
					{
						fl = _labels[currentIndex] as FrameLabel;
						
					}else{
						
						fl = _labels[currentIndex - 1] as FrameLabel;
						
					}
					
					return fl
				}
				
				return fl;
			}
			
			protected function getLabelIndex():int
			{
				_labels.sortOn("frame", Array.NUMERIC | Array.DESCENDING);
				
				var currentFrame:int = (swfLoader.content as MovieClip).currentFrame;
				
				for(var i:uint=0; i<_labels.length; i++)
				{
					if(currentFrame == (_labels[i] as FrameLabel).frame)
					{
						return i;
					}
				}
				
				return -1;
				
			}
		]]>
	</mx:Script>
	
	<mx:VBox width="100%" height="100%" 
		id="container">
		
		<mx:Canvas width="100%" height="100%"
			id="swfLoaderContainer">
			
			<mx:SWFLoader width="100%" height="100%"
			id="swfLoader"
			styleName="missingImageStyle"
			complete="onSWFLoaderComplete(event)"/>
			
		</mx:Canvas>	
				
		<mx:HBox width="100%"
			id="controls" horizontalGap="2"
			paddingTop="2"
			paddingBottom="2"
			paddingLeft="2"
			paddingRight="2">
			
				<mx:Button width="32"
					id="back" 
					upSkin="{backBtn}"
					overSkin="{backRolloverBtn}"
					downSkin="{backRolloverBtn}"
					click="onBack(event)"/>
					
				<mx:Button width="32"
					id="stop" 
					upSkin="{pauseBtn}"
					overSkin="{pauseRolloverBtn}"
					downSkin="{pauseRolloverBtn}"
					click="onStop(event)"/>
					
				<mx:Button width="32"
					id="play" 
					upSkin="{playBtn}"
					overSkin="{playRolloverBtn}"
					downSkin="{playRolloverBtn}"
					click="onPlay(event)"/>
									
				<mx:Button width="32"
					id="fwd" 
					upSkin="{fwdBtn}"
					overSkin="{fwdRolloverBtn}"
					downSkin="{fwdRolloverBtn}"
					click="onFwd(event)"/>

		</mx:HBox>
		
	</mx:VBox>
	
</BaseComponent>